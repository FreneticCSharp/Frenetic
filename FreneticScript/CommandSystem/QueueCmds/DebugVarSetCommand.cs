//
// This file is part of FreneticScript, created by Frenetic LLC.
// This code is Copyright (C) Frenetic LLC under the terms of the MIT license.
// See README.md or LICENSE.txt in the FreneticScript source root for the contents of the license.
//

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using FreneticScript.TagHandlers;
using FreneticScript.TagHandlers.Objects;
using System.Reflection;
using System.Reflection.Emit;
using FreneticUtilities.FreneticExtensions;
using FreneticScript.ScriptSystems;

namespace FreneticScript.CommandSystem.QueueCmds
{
    /// <summary>
    /// Sets a var, for use with the compiler logic. Generally not used directly, but rather generated by the compiler for calls with a var-set style syntax.
    /// </summary>
    public class DebugVarSetCommand : AbstractCommand
    {
        // NOTE: Intentionally no meta!
        
        /// <summary>
        /// Adapts a command entry to CIL.
        /// </summary>
        /// <param name="values">The adaptation-relevant values.</param>
        /// <param name="entry">The present entry ID.</param>
        public override void AdaptToCIL(CILAdaptationValues values, int entry)
        {
            // TODO: Type verification? (Can this type be modified in the way being attempted?)
            values.MarkCommand(entry);
            CommandEntry cent = values.Entry.Entries[entry];
            bool debug = cent.DBMode.ShouldShow(DebugMode.FULL);
            string vn = cent.Arguments[0].ToString().ToLowerFast();
            string[] split = vn.Split('.');
            string mainVar = split[0];
            if (!cent.VarLookup.TryGetValue(mainVar, out SingleCILVariable locVar))
            {
                throw new ErrorInducedException("Unknown variable name '" + mainVar + "' - cannot set its value.");
            }
            TagType varType = locVar.Type;
            if (split.Length > 1)
            {
                if (varType.Operation_GetSubSettable == null)
                {
                    throw new ErrorInducedException("Cannot get sub-objects on a variable of type '" + varType.TypeName + "'!");
                }
                // TODO
            }
            string mode = cent.Arguments[1].ToString();
            if (mode == "=")
            {
                values.LoadQueue();
                values.ILGen.Emit(OpCodes.Ldc_I4, locVar.Index);
                values.LoadArgumentObject(entry, 2);
                values.EnsureType(cent.Arguments[2], varType);
                values.ILGen.Emit(OpCodes.Call, CILAdaptationValues.Queue_SetLocalVarMethod);
            }
            else
            {
                ObjectOperationAttribute operation;
                switch (mode)
                {
                    case "+=":
                        operation = varType.Operation_Add;
                        break;
                    case "-=":
                        operation = varType.Operation_Subtract;
                        break;
                    case "*=":
                        operation = varType.Operation_Multiply;
                        break;
                    case "/=":
                        operation = varType.Operation_Divide;
                        break;
                    default:
                        throw new ErrorInducedException("That setter mode (" + mode + ") does not exist!");
                }
                if (operation == null)
                {
                    throw new ErrorInducedException("Cannot use that setter mode (" + mode + ") on a variable of type '" + varType.TypeName + "'!");
                }
                // This method: Queue.SetLocalVar(index, vars[varloc].Operation(entry.args[2]))
                values.LoadQueue();
                values.ILGen.Emit(OpCodes.Ldc_I4, locVar.Index);
                values.LoadLocalVariable(locVar.Index);
                values.LoadArgumentObject(entry, 2);
                values.EnsureType(cent.Arguments[2], varType);
                values.ILGen.Emit(OpCodes.Call, operation.Method);
                values.ILGen.Emit(OpCodes.Call, CILAdaptationValues.Queue_SetLocalVarMethod);
            }
            if (debug) // If in debug mode...
            {
                values.ILGen.Emit(OpCodes.Ldc_I4, locVar.Index);
                values.ILGen.Emit(OpCodes.Ldstr, vn);
                values.LoadQueue();
                values.LoadEntry(entry);
                values.ILGen.Emit(OpCodes.Call, Method_DebugHelper);
            }
        }

        /// <summary>
        /// References <see cref="DebugHelper(int, string, CommandQueue, CommandEntry)"/>.
        /// </summary>
        public static MethodInfo Method_DebugHelper = typeof(DebugVarSetCommand).GetMethod(nameof(DebugHelper));

        /// <summary>
        /// Helps debug output for the var-set command.
        /// </summary>
        /// <param name="varloc">The var location.</param>
        /// <param name="varName">The variable name.</param>
        /// <param name="queue">The queue.</param>
        /// <param name="entry">The entry.</param>
        public static void DebugHelper(int varloc, string varName, CommandQueue queue, CommandEntry entry)
        {
            if (entry.ShouldShowGood(queue))
            {
                TemplateObject resultObject = queue.CurrentStackEntry.LocalVariables[varloc].Internal;
                entry.GoodOutput(queue, "Updated variable '" + TextStyle.Separate + varName + TextStyle.Outgood + "' to value: " + TextStyle.Separate + resultObject.GetDebugString());
            }
        }
        
        /// <summary>
        /// Gets an object edit source for a queue+entry pair.
        /// </summary>
        /// <param name="queue">The queue.</param>
        /// <param name="entry">The entry.</param>
        /// <returns>The edit source.</returns>
        public static ObjectEditSource GetOES(CommandQueue queue, CommandEntry entry)
        {
            return new ObjectEditSource() { Queue = queue, Entry = entry, Error = queue.Error };
        }

        /// <summary>
        /// Constructs the command.
        /// </summary>
        public DebugVarSetCommand()
        {
            Name = "\0DebugVarSet";
            Arguments = "<invalid command name>";
            Description = "Sets or modifies a variable.";
            IsDebug = true;
            IsFlow = true;
            Asyncable = true;
            MinimumArguments = 3;
            MaximumArguments = 3;
        }
        
        /// <summary>
        /// Executs the command.
        /// </summary>
        /// <param name="queue">The command queue involved.</param>
        /// <param name="entry">The entry to execute with.</param>
        public static void Execute(CommandQueue queue, CommandEntry entry)
        {
            queue.HandleError(entry, "This command MUST be compiled!");
        }
    }
}
