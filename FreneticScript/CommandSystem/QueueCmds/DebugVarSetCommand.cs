//
// This file is part of FreneticScript, created by Frenetic LLC.
// This code is Copyright (C) Frenetic LLC under the terms of the MIT license.
// See README.md or LICENSE.txt in the FreneticScript source root for the contents of the license.
//

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using FreneticScript.TagHandlers;
using FreneticScript.TagHandlers.Objects;
using System.Reflection;
using System.Reflection.Emit;
using FreneticUtilities.FreneticExtensions;

namespace FreneticScript.CommandSystem.QueueCmds
{
    /// <summary>
    /// Sets a var, for use with the compiler logic. Generally not used directly, but rather generated by the compiler for calls with a var-set style syntax.
    /// </summary>
    public class DebugVarSetCommand : AbstractCommand
    {
        // NOTE: Intentionally no meta!
        
        /// <summary>
        /// Adapts a command entry to CIL.
        /// </summary>
        /// <param name="values">The adaptation-relevant values.</param>
        /// <param name="entry">The present entry ID.</param>
        public override void AdaptToCIL(CILAdaptationValues values, int entry)
        {
            // TODO: Type verification? (Can this type be modified in the way being attempted?)
            values.MarkCommand(entry);
            CommandEntry cent = values.Entry.Entries[entry];
            bool debug = cent.DBMode.ShouldShow(DebugMode.FULL);
            string vn = cent.Arguments[0].ToString().ToLowerFast();
            // TODO: Index "after" check instead of splitty weirdness?
            string[] dat = vn.SplitFast('.');
            StringBuilder res = new StringBuilder(vn.Length);
            for (int i = 1; i < dat.Length; i++)
            {
                res.Append(dat[i]);
                if (i + 1 < dat.Length)
                {
                    res.Append('.');
                }
            }
            vn = dat[0];
            int lvarloc = cent.VarLoc(vn);
            if (lvarloc < 0)
            {
                throw new ErrorInducedException("Unknown variable name '" + vn + "' - cannot set its value.");
            }
            string mode = cent.Arguments[1].ToString();
            bool fasto = mode == "=" && res.ToString().Length == 0;
            values.ILGen.Emit(OpCodes.Ldc_I4, lvarloc);
            if (!fasto)
            {
                // TODO: generate a field somewhere to store a pre-split value, rather than requiring it be split by the called methods!
                values.ILGen.Emit(OpCodes.Ldstr, res.ToString());
            }
            values.LoadQueue();
            values.LoadEntry(entry);
            // TODO: verify that the given mode is valid for the relevant tag type.
            switch (mode)
            {
                case "=":
                    values.ILGen.Emit(OpCodes.Call, fasto ? Method_SetImmediateFast : Method_SetImmediate);
                    break;
                case "+=":
                    values.ILGen.Emit(OpCodes.Call, Method_AddImmediate);
                    break;
                case "-=":
                    values.ILGen.Emit(OpCodes.Call, Method_SubtractImmediate);
                    break;
                case "*=":
                    values.ILGen.Emit(OpCodes.Call, Method_MultiplyImmediate);
                    break;
                case "/=":
                    values.ILGen.Emit(OpCodes.Call, Method_DivideImmediate);
                    break;
                default:
                    throw new NotSupportedException("That setter mode (" + mode + ") is not available!");
            }
            if (debug) // If in debug mode...
            {
                values.ILGen.Emit(OpCodes.Ldc_I4, lvarloc);
                values.ILGen.Emit(OpCodes.Ldstr, vn);
                values.LoadQueue();
                values.LoadEntry(entry);
                values.ILGen.Emit(OpCodes.Call, Method_DebugHelper);
            }
        }

        /// <summary>
        /// References <see cref="DebugHelper(int, string, CommandQueue, CommandEntry)"/>.
        /// </summary>
        public static MethodInfo Method_DebugHelper = typeof(VarCommand).GetMethod(nameof(DebugHelper));

        /// <summary>
        /// Helps debug output for the var-set command.
        /// </summary>
        /// <param name="varloc">The var location.</param>
        /// <param name="varName">The variable name.</param>
        /// <param name="queue">The queue.</param>
        /// <param name="entry">The entry.</param>
        public static void DebugHelper(int varloc, string varName, CommandQueue queue, CommandEntry entry)
        {
            if (entry.ShouldShowGood(queue))
            {
                TemplateObject resultObject = queue.CurrentStackEntry.LocalVariables[varloc].Internal;
                entry.GoodOutput(queue, "Updated variable '" + TextStyle.Separate + varName + TextStyle.Outgood + "' to value: " + TextStyle.Separate + resultObject.GetDebugString());
            }
        }

        /// <summary>
        /// References <see cref="SetImmediateFast(int, CommandQueue, CommandEntry)"/>.
        /// </summary>
        public static MethodInfo Method_SetImmediateFast = typeof(DebugVarSetCommand).GetMethod("SetImmediateFast");

        /// <summary>
        /// References <see cref="SetImmediate(int, string, CommandQueue, CommandEntry)"/>.
        /// </summary>
        public static MethodInfo Method_SetImmediate = typeof(DebugVarSetCommand).GetMethod("SetImmediate");

        /// <summary>
        /// References <see cref="AddImmediate(int, string, CommandQueue, CommandEntry)"/>.
        /// </summary>
        public static MethodInfo Method_AddImmediate = typeof(DebugVarSetCommand).GetMethod("AddImmediate");

        /// <summary>
        /// References <see cref="SubtractImmediate(int, string, CommandQueue, CommandEntry)"/>.
        /// </summary>
        public static MethodInfo Method_SubtractImmediate = typeof(DebugVarSetCommand).GetMethod("SubtractImmediate");

        /// <summary>
        /// References <see cref="MultiplyImmediate(int, string, CommandQueue, CommandEntry)"/>.
        /// </summary>
        public static MethodInfo Method_MultiplyImmediate = typeof(DebugVarSetCommand).GetMethod("MultiplyImmediate");

        /// <summary>
        /// References <see cref="DivideImmediate(int, string, CommandQueue, CommandEntry)"/>.
        /// </summary>
        public static MethodInfo Method_DivideImmediate = typeof(DebugVarSetCommand).GetMethod("DivideImmediate");

        /// <summary>
        /// Empty string array.
        /// </summary>
        private static readonly string[] EMPTY = new string[0];

        /// <summary>
        /// Immediately sets a var, for compiler reasons.
        /// </summary>
        /// <param name="loc">The var location.</param>
        /// <param name="queue">The relevant queue.</param>
        /// <param name="entry">The relevant entry.</param>
        public static void SetImmediateFast(int loc, CommandQueue queue, CommandEntry entry)
        {
            try
            {
                queue.CurrentStackEntry.LocalVariables[loc].Internal.SetFast(entry.GetArgumentObject(queue, 2));
            }
            catch (ErrorInducedException ex)
            {
                queue.HandleError(entry, "Error while setting a variable value: " + ex.Message);
            }
        }

        /// <summary>
        /// Gets an object edit source for a queue+entry pair.
        /// </summary>
        /// <param name="queue">The queue.</param>
        /// <param name="entry">The entry.</param>
        /// <returns>The edit source.</returns>
        public static ObjectEditSource GetOES(CommandQueue queue, CommandEntry entry)
        {
            return new ObjectEditSource() { Queue = queue, Entry = entry, Error = queue.Error };
        }

        /// <summary>
        /// Immediately sets a var, for compiler reasons.
        /// </summary>
        /// <param name="loc">The var location.</param>
        /// <param name="sdat">The split data variable.</param>
        /// <param name="queue">The relevant queue.</param>
        /// <param name="entry">The relevant entry.</param>
        public static void SetImmediate(int loc, string sdat, CommandQueue queue, CommandEntry entry)
        {
            // TODO: Pre-split!
            queue.CurrentStackEntry.LocalVariables[loc].Internal.Set(sdat.Length == 0 ? EMPTY : sdat.SplitFast('.'), entry.GetArgumentObject(queue, 2), GetOES(queue, entry));
        }

        /// <summary>
        /// Immediately adds a var, for compiler reasons.
        /// </summary>
        /// <param name="loc">The var location.</param>
        /// <param name="sdat">The split data variable.</param>
        /// <param name="queue">The relevant queue.</param>
        /// <param name="entry">The relevant entry.</param>
        public static void AddImmediate(int loc, string sdat, CommandQueue queue, CommandEntry entry)
        {
            // TODO: Pre-split!
            queue.CurrentStackEntry.LocalVariables[loc].Internal.Add(sdat.Length == 0 ? EMPTY : sdat.SplitFast('.'), entry.GetArgumentObject(queue, 2), GetOES(queue, entry));
        }

        /// <summary>
        /// Immediately subtracts a var, for compiler reasons.
        /// </summary>
        /// <param name="loc">The var location.</param>
        /// <param name="sdat">The split data variable.</param>
        /// <param name="queue">The relevant queue.</param>
        /// <param name="entry">The relevant entry.</param>
        public static void SubtractImmediate(int loc, string sdat, CommandQueue queue, CommandEntry entry)
        {
            // TODO: Pre-split!
            queue.CurrentStackEntry.LocalVariables[loc].Internal.Subtract(sdat.Length == 0 ? EMPTY : sdat.SplitFast('.'), entry.GetArgumentObject(queue, 2), GetOES(queue, entry));
        }

        /// <summary>
        /// Immediately multiplies a var, for compiler reasons.
        /// </summary>
        /// <param name="loc">The var location.</param>
        /// <param name="sdat">The split data variable.</param>
        /// <param name="queue">The relevant queue.</param>
        /// <param name="entry">The relevant entry.</param>
        public static void MultiplyImmediate(int loc, string sdat, CommandQueue queue, CommandEntry entry)
        {
            // TODO: Pre-split!
            queue.CurrentStackEntry.LocalVariables[loc].Internal.Multiply(sdat.Length == 0 ? EMPTY : sdat.SplitFast('.'), entry.GetArgumentObject(queue, 2), GetOES(queue, entry));
        }

        /// <summary>
        /// Immediately divides a var, for compiler reasons.
        /// </summary>
        /// <param name="loc">The var location.</param>
        /// <param name="sdat">The split data variable.</param>
        /// <param name="queue">The relevant queue.</param>
        /// <param name="entry">The relevant entry.</param>
        public static void DivideImmediate(int loc, string sdat, CommandQueue queue, CommandEntry entry)
        {
            // TODO: Pre-split!
            queue.CurrentStackEntry.LocalVariables[loc].Internal.Divide(sdat.Length == 0 ? EMPTY : sdat.SplitFast('.'), entry.GetArgumentObject(queue, 2), GetOES(queue, entry));
        }

        /// <summary>
        /// Constructs the command.
        /// </summary>
        public DebugVarSetCommand()
        {
            Name = "\0DebugVarSet";
            Arguments = "<invalid command name>";
            Description = "Sets or modifies a variable.";
            IsDebug = true;
            IsFlow = true;
            Asyncable = true;
            MinimumArguments = 3;
            MaximumArguments = 3;
            ObjectTypes = new List<Func<TemplateObject, TemplateObject>>()
            {
                PreLowerBaseVar,
                TextTag.For,
                TemplateObject.Basic_For
            };
        }

        /// <summary>
        /// Pre-lowers the base variable.
        /// </summary>
        /// <param name="inp">The input variable block.</param>
        public TemplateObject PreLowerBaseVar(TemplateObject inp)
        {
            string ins = inp.ToString();
            string[] dat = ins.SplitFast('.');
            dat[0] = dat[0].ToLowerFast();
            StringBuilder sb = new StringBuilder(ins.Length);
            for (int i = 0; i < dat.Length; i++)
            {
                sb.Append(dat[i]);
                if (i + 1 < dat.Length)
                {
                    sb.Append('.');
                }
            }
            return new TextTag(sb.ToString());
        }
        
        /// <summary>
        /// Executs the command.
        /// </summary>
        /// <param name="queue">The command queue involved.</param>
        /// <param name="entry">The entry to execute with.</param>
        public static void Execute(CommandQueue queue, CommandEntry entry)
        {
            queue.HandleError(entry, "This command MUST be compiled!");
        }
    }
}
