//
// This file is part of FreneticScript, created by Frenetic LLC.
// This code is Copyright (C) Frenetic LLC under the terms of the MIT license.
// See README.md or LICENSE.txt in the FreneticScript source root for the contents of the license.
//

using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using FreneticScript.TagHandlers;
using FreneticScript.TagHandlers.Objects;
using System.Reflection;
using System.Reflection.Emit;
using FreneticUtilities.FreneticExtensions;
using FreneticScript.ScriptSystems;

namespace FreneticScript.CommandSystem.QueueCmds
{
    /// <summary>
    /// Sets a var, for use with the compiler logic. Generally not used directly, but rather generated by the compiler for calls with a var-set style syntax.
    /// </summary>
    public class DebugVarSetCommand : AbstractCommand
    {
        // NOTE: Intentionally no meta!
        
        /// <summary>
        /// Adapts a command entry to CIL.
        /// </summary>
        /// <param name="values">The adaptation-relevant values.</param>
        /// <param name="entry">The present entry ID.</param>
        public override void AdaptToCIL(CILAdaptationValues values, int entry)
        {
            // TODO: Type verification? (Can this type be modified in the way being attempted?)
            values.MarkCommand(entry);
            CommandEntry cent = values.Entry.Entries[entry];
            bool debug = cent.DBMode.ShouldShow(DebugMode.FULL);
            string vn = cent.Arguments[0].ToString().ToLowerFast();
            string mainVar = vn.BeforeAndAfter('.', out string subVar);
            if (!cent.VarLookup.TryGetValue(mainVar, out SingleCILVariable locVar))
            {
                throw new ErrorInducedException("Unknown variable name '" + mainVar + "' - cannot set its value.");
            }
            string mode = cent.Arguments[1].ToString();
            bool fasto = mode == "=" && subVar.Length == 0;
            values.ILGen.Emit(OpCodes.Ldc_I4, locVar.Index);
            if (!fasto)
            {
                // TODO: generate a field somewhere to store a pre-split value, rather than requiring it be split by the called methods!
                values.ILGen.Emit(OpCodes.Ldstr, subVar);
            }
            values.LoadQueue();
            values.LoadEntry(entry);
            // TODO: verify that the given mode is valid for the relevant tag type.
            switch (mode)
            {
                case "=":
                    values.ILGen.Emit(OpCodes.Call, fasto ? (locVar.Type.DefinesSetMethod ? Method_SetImmediateFast : Method_RawSetImmediateFast) : Method_SetImmediate);
                    break;
                case "+=":
                    values.ILGen.Emit(OpCodes.Call, Method_AddImmediate);
                    break;
                case "-=":
                    values.ILGen.Emit(OpCodes.Call, Method_SubtractImmediate);
                    break;
                case "*=":
                    values.ILGen.Emit(OpCodes.Call, Method_MultiplyImmediate);
                    break;
                case "/=":
                    values.ILGen.Emit(OpCodes.Call, Method_DivideImmediate);
                    break;
                default:
                    throw new NotSupportedException("That setter mode (" + mode + ") is not available!");
            }
            if (debug) // If in debug mode...
            {
                values.ILGen.Emit(OpCodes.Ldc_I4, locVar.Index);
                values.ILGen.Emit(OpCodes.Ldstr, vn);
                values.LoadQueue();
                values.LoadEntry(entry);
                values.ILGen.Emit(OpCodes.Call, Method_DebugHelper);
            }
        }

        /// <summary>
        /// References <see cref="DebugHelper(int, string, CommandQueue, CommandEntry)"/>.
        /// </summary>
        public static MethodInfo Method_DebugHelper = typeof(DebugVarSetCommand).GetMethod(nameof(DebugHelper));

        /// <summary>
        /// Helps debug output for the var-set command.
        /// </summary>
        /// <param name="varloc">The var location.</param>
        /// <param name="varName">The variable name.</param>
        /// <param name="queue">The queue.</param>
        /// <param name="entry">The entry.</param>
        public static void DebugHelper(int varloc, string varName, CommandQueue queue, CommandEntry entry)
        {
            if (entry.ShouldShowGood(queue))
            {
                TemplateObject resultObject = queue.CurrentStackEntry.LocalVariables[varloc].Internal;
                entry.GoodOutput(queue, "Updated variable '" + TextStyle.Separate + varName + TextStyle.Outgood + "' to value: " + TextStyle.Separate + resultObject.GetDebugString());
            }
        }

        /// <summary>
        /// References <see cref="SetImmediateFast(int, CommandQueue, CommandEntry)"/>.
        /// </summary>
        public static MethodInfo Method_SetImmediateFast = typeof(DebugVarSetCommand).GetMethod("SetImmediateFast");

        /// <summary>
        /// References <see cref="RawSetImmediateFast(int, CommandQueue, CommandEntry)"/>.
        /// </summary>
        public static MethodInfo Method_RawSetImmediateFast = typeof(DebugVarSetCommand).GetMethod("RawSetImmediateFast");

        /// <summary>
        /// References <see cref="SetImmediate(int, string, CommandQueue, CommandEntry)"/>.
        /// </summary>
        public static MethodInfo Method_SetImmediate = typeof(DebugVarSetCommand).GetMethod("SetImmediate");

        /// <summary>
        /// References <see cref="AddImmediate(int, string, CommandQueue, CommandEntry)"/>.
        /// </summary>
        public static MethodInfo Method_AddImmediate = typeof(DebugVarSetCommand).GetMethod("AddImmediate");

        /// <summary>
        /// References <see cref="SubtractImmediate(int, string, CommandQueue, CommandEntry)"/>.
        /// </summary>
        public static MethodInfo Method_SubtractImmediate = typeof(DebugVarSetCommand).GetMethod("SubtractImmediate");

        /// <summary>
        /// References <see cref="MultiplyImmediate(int, string, CommandQueue, CommandEntry)"/>.
        /// </summary>
        public static MethodInfo Method_MultiplyImmediate = typeof(DebugVarSetCommand).GetMethod("MultiplyImmediate");

        /// <summary>
        /// References <see cref="DivideImmediate(int, string, CommandQueue, CommandEntry)"/>.
        /// </summary>
        public static MethodInfo Method_DivideImmediate = typeof(DebugVarSetCommand).GetMethod("DivideImmediate");

        /// <summary>
        /// Empty string array.
        /// </summary>
        private static readonly string[] EMPTY = new string[0];

        /// <summary>
        /// Immediately sets a var that lacks a set method, for compiler reasons.
        /// </summary>
        /// <param name="loc">The var location.</param>
        /// <param name="queue">The relevant queue.</param>
        /// <param name="entry">The relevant entry.</param>
        public static void RawSetImmediateFast(int loc, CommandQueue queue, CommandEntry entry)
        {
            try
            {
                queue.CurrentStackEntry.LocalVariables[loc].Internal = entry.GetArgumentObject(queue, 2);
            }
            catch (ErrorInducedException ex)
            {
                queue.HandleError(entry, "Error while setting a variable value: " + ex.Message);
            }
        }

        /// <summary>
        /// Immediately sets a var, for compiler reasons.
        /// </summary>
        /// <param name="loc">The var location.</param>
        /// <param name="queue">The relevant queue.</param>
        /// <param name="entry">The relevant entry.</param>
        public static void SetImmediateFast(int loc, CommandQueue queue, CommandEntry entry)
        {
            try
            {
                queue.CurrentStackEntry.LocalVariables[loc].Internal.SetFast(entry.GetArgumentObject(queue, 2));
            }
            catch (ErrorInducedException ex)
            {
                queue.HandleError(entry, "Error while setting a variable value: " + ex.Message);
            }
        }

        /// <summary>
        /// Gets an object edit source for a queue+entry pair.
        /// </summary>
        /// <param name="queue">The queue.</param>
        /// <param name="entry">The entry.</param>
        /// <returns>The edit source.</returns>
        public static ObjectEditSource GetOES(CommandQueue queue, CommandEntry entry)
        {
            return new ObjectEditSource() { Queue = queue, Entry = entry, Error = queue.Error };
        }

        /// <summary>
        /// Immediately sets a var, for compiler reasons.
        /// </summary>
        /// <param name="loc">The var location.</param>
        /// <param name="sdat">The split data variable.</param>
        /// <param name="queue">The relevant queue.</param>
        /// <param name="entry">The relevant entry.</param>
        public static void SetImmediate(int loc, string sdat, CommandQueue queue, CommandEntry entry)
        {
            // TODO: Pre-split!
            queue.CurrentStackEntry.LocalVariables[loc].Internal.Set(sdat.Length == 0 ? EMPTY : sdat.SplitFast('.'), entry.GetArgumentObject(queue, 2), GetOES(queue, entry));
        }

        /// <summary>
        /// Immediately adds a var, for compiler reasons.
        /// </summary>
        /// <param name="loc">The var location.</param>
        /// <param name="sdat">The split data variable.</param>
        /// <param name="queue">The relevant queue.</param>
        /// <param name="entry">The relevant entry.</param>
        public static void AddImmediate(int loc, string sdat, CommandQueue queue, CommandEntry entry)
        {
            // TODO: Pre-split!
            queue.CurrentStackEntry.LocalVariables[loc].Internal.Add(sdat.Length == 0 ? EMPTY : sdat.SplitFast('.'), entry.GetArgumentObject(queue, 2), GetOES(queue, entry));
        }

        /// <summary>
        /// Immediately subtracts a var, for compiler reasons.
        /// </summary>
        /// <param name="loc">The var location.</param>
        /// <param name="sdat">The split data variable.</param>
        /// <param name="queue">The relevant queue.</param>
        /// <param name="entry">The relevant entry.</param>
        public static void SubtractImmediate(int loc, string sdat, CommandQueue queue, CommandEntry entry)
        {
            // TODO: Pre-split!
            queue.CurrentStackEntry.LocalVariables[loc].Internal.Subtract(sdat.Length == 0 ? EMPTY : sdat.SplitFast('.'), entry.GetArgumentObject(queue, 2), GetOES(queue, entry));
        }

        /// <summary>
        /// Immediately multiplies a var, for compiler reasons.
        /// </summary>
        /// <param name="loc">The var location.</param>
        /// <param name="sdat">The split data variable.</param>
        /// <param name="queue">The relevant queue.</param>
        /// <param name="entry">The relevant entry.</param>
        public static void MultiplyImmediate(int loc, string sdat, CommandQueue queue, CommandEntry entry)
        {
            // TODO: Pre-split!
            queue.CurrentStackEntry.LocalVariables[loc].Internal.Multiply(sdat.Length == 0 ? EMPTY : sdat.SplitFast('.'), entry.GetArgumentObject(queue, 2), GetOES(queue, entry));
        }

        /// <summary>
        /// Immediately divides a var, for compiler reasons.
        /// </summary>
        /// <param name="loc">The var location.</param>
        /// <param name="sdat">The split data variable.</param>
        /// <param name="queue">The relevant queue.</param>
        /// <param name="entry">The relevant entry.</param>
        public static void DivideImmediate(int loc, string sdat, CommandQueue queue, CommandEntry entry)
        {
            // TODO: Pre-split!
            queue.CurrentStackEntry.LocalVariables[loc].Internal.Divide(sdat.Length == 0 ? EMPTY : sdat.SplitFast('.'), entry.GetArgumentObject(queue, 2), GetOES(queue, entry));
        }

        /// <summary>
        /// Constructs the command.
        /// </summary>
        public DebugVarSetCommand()
        {
            Name = "\0DebugVarSet";
            Arguments = "<invalid command name>";
            Description = "Sets or modifies a variable.";
            IsDebug = true;
            IsFlow = true;
            Asyncable = true;
            MinimumArguments = 3;
            MaximumArguments = 3;
        }
        
        /// <summary>
        /// Executs the command.
        /// </summary>
        /// <param name="queue">The command queue involved.</param>
        /// <param name="entry">The entry to execute with.</param>
        public static void Execute(CommandQueue queue, CommandEntry entry)
        {
            queue.HandleError(entry, "This command MUST be compiled!");
        }
    }
}
